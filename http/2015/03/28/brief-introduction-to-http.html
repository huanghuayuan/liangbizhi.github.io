<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link rel="stylesheet" type="text/css" href="/css/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/css/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/css/print.css" media="print">
    <link rel="stylesheet" type="text/css" href="/css/default.css">
    <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico">
    <script src="/js/jquery-1.11.1.min.js" type="text/javascript"></script>
    <script src="/js/default.js" type="text/javascript"></script>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>浅谈HTTP协议</title>
  </head>
  <body>

    <div class="nav">
	<div style="width: 920px; margin: 0 auto; height: inherit">
	<a id="logo" href="/" title="点击返回首页">必苦其心志的小窝</a>
	<div id="follow">
		<a id="google-plus" title="My google+" href="https://plus.google.com/107690026046415883872" target="_blank"></a>
		<a id="weibo" title="My weibo" href="http://weibo.com/bikuqixinzhi" target="_blank"></a>
		<a id="github" title="My github" href="https://github.com/liangbizhi" target="_blank"></a>
        </div>
	<div class="submenu">
		<div class="avatar-frame">
			<a id="avatar" title="为什么不点一下？" href="/about/index.html" target="_self"></a>
		</div>
		<ul class="categories-list">
	<div>Categories</div>
	
		
		<li>
		<a href="/胡思乱想">胡思乱想 (1)</a>
		</li>
		
	
		
		<li>
		<a href="/扯淡的日常">扯淡的日常 (1)</a>
		</li>
		
	
		
		<li>
		<a href="/java">java (1)</a>
		</li>
		
	
		
		<li>
		<a href="/http">http (1)</a>
		</li>
		
	
</ul>

		<ul class="monthly-list">
	<div>Archives</div>
	

	

	

		
		
		

		
			
			<li>
			<a href="/2015/03">
				2015-03 (1)
			</a>
			</li>
			
		
	

		
		
		

		
	

		
		
		

		
			
			<li>
			<a href="/2015/01">
				2015-01 (2)
			</a>
			</li>
			
		
	

		
		
		

		
			
			<li>
			<a href="/2014/10">
				2014-10 (1)
			</a>
			</li>
			
		
	
</ul>

	</div>
</div>
</div>


    <div id="container">
      <div class="inner">

	<div id="article-title">浅谈HTTP协议</div>

	<p>平常我们在浏览器输入一个网址，点击一个超链接，就能访问网页。这再简单不过了，下面就来谈谈打开网页这一过程都发生了什么。</p>

<p>首先介绍一下HTTP（HyperText Transfer Protocol）协议，它定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。为应用层协议。主要特点如下：</p>

<ul>
<li><p>面向事务（transaction oriented）。HTTP信息交换过程是一个不可分割的整体，要么所有的信息交换都完成，要么一次交换都不进行。</p></li>
<li><p>无连接。HTTP虽然使用了面向连接的TCP作为运输层协议，以保证数据的可靠传输。但HTTP协议本身是无连接的，双方在交换HTTP报文之前不需要先建立HTTP连接。</p></li>
<li><p>无状态。表示服务器不会在不同的请求之间追踪客户端的偏好。就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同。</p></li>
</ul>

<h1>1. URL</h1>

<p>如果要访问此博客，我们就要在浏览器地址栏输入下面的地址：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">http://liangbizhi.github.io/
</code></pre></div>
<p><img src="/images/brief-introduction-to-http/surf.jpg" alt="http://liangbizhi.github.io/" title="浏览器地址栏"></p>

<p>这就是我们最常见的HTTP方案（scheme）URL，它由几部分组成。基本格式为</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">http://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;
</code></pre></div>
<ol>
<li><strong>scheme方案</strong>。对于HTTP来说当然是<code>http://</code>了，它告知了web客户端要使用HTTP协议访问资源。</li>
<li><strong>host主机</strong>。主机名，还可以为IP地址。这里为<code>liangbizhi.github.io</code>。</li>
<li><strong>port端口</strong>。服务器正在监听的网络端口。这里为默认端口80。</li>
<li><strong>path路径</strong>。服务器定位资源时所需的信息。</li>
<li><strong>query查询字符串</strong>。很多资源，如数据库服务，都是可以通过提问题或进行查询缩小所请求资源类型范围的。</li>
<li><strong>frag片段</strong>。表示资源内部的片段。这个和锚点相似。</li>
</ol>

<h1>2. 连接</h1>

<p>当我们按下回车键的时候，电脑就开始忙活了。</p>

<h2>2.1 连接过程</h2>

<ol>
<li>首先，我们得知道要和谁连接。没错，<code>liangbizhi.github.io</code>。我们知道HTTP使用了面向连接的TCP作为运输层协议。TCP报文首部的前2个字节需要分别写入<strong>源端口号</strong>和<strong>目的端口号</strong>。到了网络层，TCP报文作为IP数据报的数据部分，IP数据报首部需要写入<strong>源地址</strong>和<strong>目的地址</strong>。从哪里找目的地址和端口号呢？当然是分析URL了。取得主机名，然后查询DNS服务器将主机名转换为IP地址；取得端口号，默认80。第一步已经完成。</li>
<li>浏览器与服务器建立一条TCP连接。</li>
<li>浏览器向服务器发送一条HTTP请求报文。</li>
<li>服务器向浏览器返回一条HTTP响应报文。</li>
<li>关闭连接，浏览器显示文档。</li>
</ol>

<h2>2.2 HTTP报文</h2>

<p>HTTP报文是简单的格式化数据块。所有的HTTP报文可以分为两类：请求报文和响应报文。请求报文会向web服务器请求一个动作。响应报文会将请求的结果返回给客户端。请求报文和响应报文的基本报文结构相同。</p>

<h3>2.2.1 报文结构语法</h3>

<p>HTTP报文由起始行、首部和实体三个部分组成。</p>

<ul>
<li><p>起始行和首部其实就是一行一行分隔的ASCII文本。每行都以一个行终止符作为结束，它就是“\r\n”，即回车符（ASCII码13）和换行符（ASCII码10），可以写作CRLF。</p></li>
<li><p>首部则给出了一些与主体有关的信息。首部总是应该以一个空行（CRLF）结束。所以我们会发现在首部与主体之间有个空行。</p></li>
<li><p>主体是一个可选的数据块。与起始行和首部不同，主体中可以包含文本或二进制数据，也可为空。</p></li>
</ul>

<h3>2.2.2 例子</h3>

<p>先看个例子，当我们访问这个博客首页时，浏览器（Chrome为例）发送的请求报文是什么样子的：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">GET / HTTP/1.1
Host: liangbizhi.github.io
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: Hm_lvt_7e40c0291a48934d0bc390fc85fb36db=1424791563; Hm_lpvt_7e40c0291a48934d0bc390fc85fb36db=1426303204
If-Modified-Since: Thu, 05 Mar 2015 14:59:08 GMT
</code></pre></div>
<p>第一行为起始行，它由三部分组成，以空格隔开。第一部分为方法，用来告知服务器要做些什么。这里的<code>GET</code>方法描述了浏览器希望以GET的方式获得服务器资源。常用的HTTP方法还有<code>HEAD</code>、<code>POST</code>、<code>PUT</code>、<code>TRACE</code>、<code>OPTIONS</code>、<code>DELETE</code>等，但并不是所有服务器都实现了它们。第二部分<code>/</code>，表示所请求资源为根目录。第三部分<code>HTTP/1.1</code>，描述了报文所使用的HTTP版本为1.1。</p>

<p>第二行起，为请求首部，本质上它们只是一些名/值对的列表。首部简单的语法为：名字后跟着冒号（：），然后跟上可选的空格，再跟上字段值，最后一个CRLF。现在有很多的HTTP首部，有一些是规范中定义的，还有一些是对规范的扩展。</p>

<ul>
<li><p>Host首部。为服务器提供客户端想要访问的那台机器的因特网主机名和端口号。<code>HTTP/1.1</code>要求请求中必须包含Host首部，否则服务器会以<code>400 Bad Request</code>状态码去响应。</p></li>
<li><p>Connection首部。这里的值为较老的<code>HTTP/1.0+</code> keep-alive连接，<code>HTTP/1.1</code>实现为persistent连接，它们是两种类型的持久连接。但很多客户端和服务器仍然使用早期的keep-alive连接。keep-alive表示请将一条连接保持在打开状态。所谓的持久连接指的是事务处理结束后仍然保持在打开状态的TCP连接。这样可以降低网络时延和连接建立的开销（TCP三次握手），与并行连接配合使用可能是最高效的方式。在<code>HTTP/1.1</code>中持久连接是默认打开的。</p></li>
<li><p>Cache-Control首部。<code>HTTP/1.1</code>较新的用于传输对象的缓存信息。max-age=0在请求中表示客户端向服务器请求确认资源是否被修改过，有的话返回200 OK，否则返回304 Not Modified。</p></li>
<li><p>Accept首部。用来通知服务器客户端可以接受哪些媒体类型（MIME）。
如果客户端无法使用除了Accept列表中的对象类型，则不会去下载它们。多种类型可以用逗号（,）分隔。Accept首部字段值中还可以包含一个质量值(quality，q值)列表，分号（;）相隔，它允许客户端为每种偏好类别列出多种选项，并为每种偏好关联一个优先次序。q值优先次序从低到高取值（0.0~1.0）。上面列出的Accept首部说明Chrome最愿意接收<code>text/html,application/xhtml+xml,application/xml</code>，但<code>image/webp,*/*</code>也可以。</p></li>
<li><p>User-Agent首部。用来标识客户端应用程序类型。这个首部的格式比较随意。可以是应用程序的名称，可能还会有一些描述性注释等。</p></li>
<li><p>Accept-Encoding和Accept-Language首部。它们和上面的Accept首部类似，用于HTTP的内容协商。Accept-Encoding告知服务器它可以接受哪些编码方式。如果没有该首部，服务器就可以认为客户端能接受任何编码方式。<code>gzip</code>表明采用GNU zip编码；<code>deflate</code>表明采用zlib的格式压缩的；<code>sdch</code>为Chrome支持的传输压缩算法。Accept-Language通知服务器可以接受或优选哪些语言。</p></li>
<li><p>Cookie首部。HTTP是无状态的，但很多情况下需要识别用户。除了某些HTTP首部可以承载用户相关的信息外，还可以使用胖URL（fat URL）和Cookie技术。Cookie中包含了一个由<em>名字=值</em>这样的信息构成的任意列表，这是通过HTTP响应的Set-Cookie或Set-Cookie2首部设置到用户身上去的，浏览器会将cookie集存储在浏览器的cookie数据库中，将来用户返回同一个站点时，浏览器就会挑出该服务器的那些cookie，在一个Cookie首部中将其传回去，这样就可以实现一个较为持久的会话了。</p></li>
<li><p>If-Modified-Since首部。HTTP允许缓存（浏览器缓存或代理缓存）向原始服务器发送一个“条件GET”，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体。HTTP定义了5个条件请求首部，都以“If-”前缀开头。其中If-Modified-Since条件请求会指示服务器：如果自指定日期后资源发生了变化，条件为true，GET就会成功执行，携带新首部的新文档会被返回给缓存，还包含了一个新的过期日期；否则条件为false，会向客户端返回一个<code>304 Not Modified</code>响应报文，但不再返回文档的实体。If-Modified-Since可以和Last-Modified响应首部配合工作。</p></li>
</ul>

<p>特别地，<code>GET</code>方法是不包含主体的，所以我们只能看到起始行和首部。而<code>POST</code>方法一般包含主体，携带向服务器发送需要处理的数据。</p>

<p>下面为对应的响应报文：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">HTTP/1.1 304 Not Modified
Date: Sat, 14 Mar 2015 07:50:18 GMT
Via: 1.1 varnish
Last-Modified: Thu, 05 Mar 2015 14:59:08 GMT
Cache-Control: max-age=600
Expires: Sat, 14 Mar 2015 08:00:17 GMT
Age: 1
Connection: keep-alive
X-Served-By: cache-hkg6820-HKG
X-Cache: HIT
X-Cache-Hits: 1
X-Timer: S1426319418.681372,VS0,VE0
Vary: Accept-Encoding
</code></pre></div>
<p>同样地，第一行为起始行（响应行）。包含了响应报文使用的HTTP版本、数字状态码以及描述性文本短语。状态码用来告诉客户端发生了什么事情。状态码一般分为五类：</p>

<table><thead>
<tr>
<th style="text-align: left">整体范围</th>
<th style="text-align: left">已定义范围</th>
<th style="text-align: left">分类</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">100~199</td>
<td style="text-align: left">100~101</td>
<td style="text-align: left">信息提示</td>
</tr>
<tr>
<td style="text-align: left">200~299</td>
<td style="text-align: left">200~206</td>
<td style="text-align: left">成功</td>
</tr>
<tr>
<td style="text-align: left">300~399</td>
<td style="text-align: left">300~305</td>
<td style="text-align: left">重定向</td>
</tr>
<tr>
<td style="text-align: left">400~499</td>
<td style="text-align: left">400~415</td>
<td style="text-align: left">客户端错误</td>
</tr>
<tr>
<td style="text-align: left">500~599</td>
<td style="text-align: left">500~505</td>
<td style="text-align: left">服务器错误</td>
</tr>
</tbody></table>

<p>这里的状态码为304，这是服务器响应If-Modified-Since请求首部的结果。上面已经解释过。后面的原因短语理论上可以为任意字符串，一般取约定的有意义的值。</p>

<p>自第二行起就为响应首部了。我们来看看都有些什么：</p>

<ul>
<li><p>Date首部。给出了报文创建的日期和时间。响应中应包含此首部，因为缓存在评估响应的新鲜度时，要用到这个服务器认定的报文创建时间和日期。</p></li>
<li><p>Via首部。在请求到达服务器的路径上，经过一个或多个代理是常见的。所谓的代理就是代表客户完成事务处理的中间人。Via首部字段列出了报文途径的每个中间节点（代理或网关）有关的信息。报文每经过一个节点，都必须将这个中间节点添加到Via列表的末尾。每个Via路标最多包含4个组件：一个可选的协议版本（没有则为默认的HTTP）、一个必须的协议版本、一个必须的节点名字（出于隐私考虑，可能为主机的假名）和一个可选的描述性注释。这里的<code>varnish</code>是一款高性能的开源HTTP加速器。</p></li>
<li><p>Last-Modified首部。该实体最后一次被修改的相关信息。对于静态资源，此值可能就是服务器文件系统所提供的最后修改日期；对于动态资源，则可能就是创建响应的时间。</p></li>
<li><p>Cache-Control和Expires首部。已缓存的文档过期后必须与服务器进行核对，如果被修改过，就要获取一份新鲜的副本。Expires首部和Cache-Control: max-age首部所做的事情实质上是一样的，但Cache-Control首部使用的是相对时间而不是绝对时间。max-age值定义了文档的最大使用期（以秒为单位），例子中表示自该文档生成600秒后（10分钟）就不再新鲜。而Expired则表示一个绝对日期。用Expired的日期减去Date首部日期，刚好是10分钟，与max-age的值一致。</p></li>
<li><p>Age首部。告诉接收端响应已产生了多长时间（以秒为单位）。</p></li>
<li><p>Connection首部。以上面的请求首部Connection对应，如果服务器愿意为其请求将连接保持在打开状态，就在响应中包含相同的首部。如果响应中没有<code>Connection: keep-alive</code>首部，客服端就会认为服务器不支持keep-alive，会在接受到响应报文之后关闭连接。</p></li>
<li><p>X-扩展首部。它们是非标准的首部，由应用程序开发者创建，还未添加到已批准的HTTP规范中去。</p></li>
<li><p>Vary首部。它列出了客户端请求首部，服务器可用这些首部来选择文档或产生定制的内容。例子的值为Accept-Encoding，所以服务器会返回一个压缩的报文。</p></li>
</ul>

<p>因为响应状态为304 Not Modified，所以这里并没有实体内容。</p>

<p>上面只是一个例子，只涉及到一部分HTTP首部和简单的介绍。更多内容可查阅相关资料。</p>

<h2>2.3 细节优化</h2>

<p>实际上，人们总是希望网页打开得越快越好——没人愿意等待一个大半天也打不开的网站。在这个互联网爆炸的年代，各种性能优化的重要性不言而喻。</p>

<h3>2.3.1 DNS优化</h3>

<p>域名解析时，为了获得IP地址需要和大量的DNS服务器通信。这是极耗费时间的。对于DNS优化，缓存是最简单和效果明显的。缓存层级：</p>

<ul>
<li>浏览器DNS缓存。</li>
<li>系统DNS缓存。</li>
<li>Hosts文件。</li>
<li>各个DNS服务器上的缓存。</li>
</ul>

<p>DNS缓存失效期通常较短，很多情况下都要重取。所以预取是个不错的方法。比如敲击某个网址时，浏览器根据历史发现你很可能去访问哪个网站，就提前给你做DNS预取了。比如敲了一个“w”时，浏览器已经帮你去找weibo.com的IP地址了。</p>

<h3>2.3.2 TCP优化</h3>

<p>HTTP/1.1允许在事务处理结束后将TCP连接保持在打开状态（持久连接），以便为未来的HTTP请求重用现存的连接，这样就可以避免耗时较长的TCP三次握手连接建立时间了。作为进一步优化，我们顺着刚才的DNS优化步骤再建立连接就好了。所以敲完第一个字母的时候，DNS解析完了就去建立连接了。这样也可以减少用户等待时间。</p>

<h3>2.3.3 HTTP传输优化</h3>

<p>HTTP允许客户端打开多条连接，并行地执行多个HTTP事务。这可能会提高页面加载速度，但不一定更快。客户端的带宽不足，打开大量连接会消耗很多内存资源等。所以我们又要用到缓存了，缓存层次结构如下：</p>

<ul>
<li>PageCache。这个最快，直接在内存中缓存了现有网页的DOM结构和渲染结果，这就是为什么点前进、后退的时候会这么快的原因。</li>
<li>HTTP Cache。文件级别，按照RFC2616缓存到本地的文件系统上。</li>
<li>代理Cache。如果通过代理服务器上网，代理服务器通常也会按照缓存标准去缓存。</li>
<li>CDN。地理上离你较近的内容服务器。取得资源的距离更近。</li>
<li>DMOC（distributed memory object caching system）。CDN主要存放的是静态数据，但是网页中通常有很多动态的数据需要查询数据库，流量多了压力就会很大，通常服务器外围还会有一层内存缓存服务器，专门缓存这些数据库中的对象。</li>
</ul>

<p>另一个HTTP常用的优化就是压缩了。报文越小，网络传输时间也就少了。大部分服务器都会对HTTP消息进行gzip压缩。这个可以通过报文首部（header）中看到。</p>

<h1>3. 极简单Web服务器</h1>

<p>了解了基本的HTTP原理，我们可以自己写一个简单的服务器来玩玩，此程序默认会打开8080端口来监听请求连接。当接收到请求报文后程序将直接打印请求报文到控制台；接着我们还可以按照HTTP协议格式发送响应报文给客户端。还行吧^_^。</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="lineno"> 1</span> <span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="lineno"> 2</span>  <span class="kn">import</span> <span class="nn">java.net.ServerSocket</span><span class="o">;</span>
<span class="lineno"> 3</span>  <span class="kn">import</span> <span class="nn">java.net.Socket</span><span class="o">;</span>
<span class="lineno"> 4</span>  <span class="kn">import</span> <span class="nn">java.net.InetAddress</span><span class="o">;</span>
<span class="lineno"> 5</span>  <span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>
<span class="lineno"> 6</span>  <span class="kn">import</span> <span class="nn">java.util.Date</span><span class="o">;</span>
<span class="lineno"> 7</span> 
<span class="lineno"> 8</span>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleWebServer</span> <span class="o">{</span>
<span class="lineno"> 9</span>      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">10</span>          <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span> <span class="o">:</span> <span class="mi">8080</span><span class="o">;</span>
<span class="lineno">11</span> 
<span class="lineno">12</span>          <span class="n">ServerSocket</span> <span class="n">serverSocket</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="lineno">13</span>          <span class="k">try</span> <span class="o">{</span>
<span class="lineno">14</span>              <span class="n">serverSocket</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ServerSocket</span><span class="o">(</span><span class="n">port</span><span class="o">);</span>
<span class="lineno">15</span>              <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;服务器成功启动！\t&quot;</span> <span class="o">+</span> <span class="k">new</span> <span class="nf">Date</span><span class="o">());</span>
<span class="lineno">16</span>          <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">17</span>              <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;服务器启动失败！端口&quot;</span> <span class="o">+</span> <span class="n">port</span> <span class="o">+</span> <span class="s">&quot;正在使用！&quot;</span><span class="o">);</span>
<span class="lineno">18</span>              <span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="lineno">19</span>          <span class="o">}</span>
<span class="lineno">20</span> 
<span class="lineno">21</span>          <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">22</span>              <span class="k">try</span> <span class="o">{</span>
<span class="lineno">23</span>                  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;正在监听端口&quot;</span> <span class="o">+</span> <span class="n">port</span> <span class="o">+</span> <span class="s">&quot;...\t&quot;</span> <span class="o">+</span> <span class="k">new</span> <span class="nf">Date</span><span class="o">());</span>
<span class="lineno">24</span>                  <span class="n">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="n">serverSocket</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>
<span class="lineno">25</span>                  <span class="n">InetAddress</span> <span class="n">cname</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="na">getInetAddress</span><span class="o">();</span>
<span class="lineno">26</span>                  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;--&gt;\t请求来自 &quot;</span> <span class="o">+</span> <span class="n">cname</span><span class="o">.</span><span class="na">getHostAddress</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;\t&quot;</span> <span class="o">+</span> <span class="k">new</span> <span class="nf">Date</span><span class="o">());</span>
<span class="lineno">27</span> 
<span class="lineno">28</span>                  <span class="n">InputStream</span> <span class="n">inputStream</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
<span class="lineno">29</span>                  <span class="kt">int</span> <span class="n">code</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="lineno">30</span>                  <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="lineno">31</span>                  <span class="k">while</span> <span class="o">((</span><span class="n">code</span> <span class="o">=</span> <span class="n">inputStream</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">32</span>                      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">code</span><span class="o">);</span>
<span class="lineno">33</span>                      <span class="k">if</span> <span class="o">(</span><span class="n">code</span> <span class="o">==</span> <span class="mi">13</span><span class="o">)</span> <span class="n">count</span><span class="o">++;</span>
<span class="lineno">34</span>                      <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">code</span> <span class="o">==</span> <span class="mi">10</span><span class="o">)</span> <span class="n">count</span><span class="o">++;</span>
<span class="lineno">35</span>                      <span class="k">else</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="lineno">36</span>                      <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
<span class="lineno">37</span>                  <span class="o">}</span>
<span class="lineno">38</span>                  <span class="n">String</span> <span class="n">line</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">;</span>
<span class="lineno">39</span>                  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;&lt;--\t输入响应报文（以单行.号结束输入）&quot;</span> <span class="o">+</span> <span class="k">new</span> <span class="nf">Date</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;：&quot;</span><span class="o">);</span>
<span class="lineno">40</span>                  <span class="n">OutputStream</span> <span class="n">outputStream</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">();</span>
<span class="lineno">41</span>                  <span class="n">PrintWriter</span> <span class="n">printWriter</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">PrintWriter</span><span class="o">(</span><span class="n">outputStream</span><span class="o">);</span>
<span class="lineno">42</span>                  <span class="n">Scanner</span> <span class="n">outputScanner</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
<span class="lineno">43</span>                  <span class="n">StringBuilder</span> <span class="n">msg</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">StringBuilder</span><span class="o">();</span>
<span class="lineno">44</span>                  <span class="k">while</span> <span class="o">(!(</span><span class="n">line</span> <span class="o">=</span> <span class="n">outputScanner</span><span class="o">.</span><span class="na">nextLine</span><span class="o">()).</span><span class="na">equals</span><span class="o">(</span><span class="s">&quot;.&quot;</span><span class="o">))</span> <span class="o">{</span>
<span class="lineno">45</span>                      <span class="n">msg</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">line</span> <span class="o">+</span> <span class="s">&quot;\r\n&quot;</span><span class="o">);</span>
<span class="lineno">46</span>                  <span class="o">}</span>
<span class="lineno">47</span>                  <span class="n">printWriter</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
<span class="lineno">48</span>                  <span class="n">printWriter</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
<span class="lineno">49</span>                  <span class="n">socket</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="lineno">50</span>                  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;&lt;--响应报文发送成功！\t&quot;</span> <span class="o">+</span> <span class="k">new</span> <span class="nf">Date</span><span class="o">());</span>
<span class="lineno">51</span>              <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">52</span>                  <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="lineno">53</span>              <span class="o">}</span>
<span class="lineno">54</span>          <span class="o">}</span>
<span class="lineno">55</span>      <span class="o">}</span>
<span class="lineno">56</span>  <span class="o">}</span></code></pre></div>

<p>用如下命令运行程序，运行结果如下图：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">javac -encoding utf-8 SimpleWebServer.java
java SimpleWebServer
</code></pre></div>
<p><img src="/images/brief-introduction-to-http/server-start.jpg" alt="服务器启动" title="服务器启动"></p>

<p>好，万事俱备只欠请求报文了。我们可以使用浏览器发送请求。在浏览器中输入如下URL：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">http://localhost:8080/
</code></pre></div>
<p>我们的服务器马上就接收到了请求报文，如下图所示。这是浏览器的标签页正在打圈加载中，因为我们的服务器还没有发送响应报文呢。</p>

<p><img src="/images/brief-introduction-to-http/loading.jpg" alt="浏览器等待响应" title="浏览器等待响应"></p>

<p><img src="/images/brief-introduction-to-http/request.jpg" alt="服务器接收请求" title="服务器接收请求"></p>

<p>好了，服务器真期待我们输入响应报文呢，我们马上按照HTTP协议规范输入响应报文吧，看看浏览器会不会接收得到。注意首部和实体之间要有一个空行哦（CRLF）。这里我特意把200状态码的原因描述短语改为了自定义的Your response msg here，为了验证上面提过的内容哦。（我这里规定单行点号“.”作为报文输入结束标记）。</p>

<p><img src="/images/brief-introduction-to-http/response.jpg" alt="服务器发送响应" title="服务器发送响应"></p>

<p>看，我们的浏览器的确接收了响应了，F12看看，一切正常。</p>

<p><img src="/images/brief-introduction-to-http/browser-response.jpg" alt="浏览器接收响应" title="浏览器接收响应"></p>

<p>当然，我们还可以尝试一下其他的状态码，比如3xx重定向转态，同时提供Location响应首部，看看浏览器会不会跳转等等。</p>

<h1>4. 参考文献</h1>

<p>[1] David Gourley 等著，陈涓 等译；HTTP权威指南 （HTTP:The Definitive Guide）；人民邮电出版社，2012</p>

<p>[2] 谢希仁 编著；计算机网络（第五版）；电子工业出版社；2012</p>

<p>[3] 某安度博客（出处有待考证）</p>


	<div class="article-date text-right">2015-03-28</div>
	<div>
		
		<a style="float: left" href="/java/2015/01/22/httpclient-4-3-x-chapter-1.html" >←较早文章：《HttpClient4.3.x第一章入门教程》</a>
		
		
	</div>
	
		<!-- 多说评论框 tart -->
	<div class="ds-thread"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"liangbizhi"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->



	<footer>
	<div style="text-align: center;">This page was created by <a href="http://weibo.com/bikuqixinzhi">@偶尔装必</a>.</div>
</footer>
<div class="back-to-top">Top</div>


      </div>
    </div>
    <script type="text/javascript">
	var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
	document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F7e40c0291a48934d0bc390fc85fb36db' type='text/javascript'%3E%3C/script%3E"));
    </script>
  </body>
</html>
